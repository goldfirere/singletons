{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeInType #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-orphans #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  Data.Singletons.Prelude.Const
-- Copyright   :  (C) 2018 Ryan Scott
-- License     :  BSD-style (see LICENSE)
-- Maintainer  :  Richard Eisenberg (rae@cs.brynmawr.edu)
-- Stability   :  experimental
-- Portability :  non-portable
--
-- Exports the promoted and singled versions of the 'Const' data type.
--
-----------------------------------------------------------------------------

module Data.Singletons.Prelude.Const (
  -- * The 'Const' singleton
  Sing(SConst, sGetConst),
  SConst, GetConst,

  -- * Defunctionalization symbols
  ConstSym0, ConstSym1,
  GetConstSym0, GetConstSym1
  ) where

import Control.Applicative
import Data.Kind (Type)
import Data.Singletons.Internal
import Data.Singletons.Prelude.Base hiding (Const, ConstSym0, ConstSym1)
import Data.Singletons.Prelude.Enum
import Data.Singletons.Prelude.Eq
import Data.Singletons.Prelude.Foldable
import Data.Singletons.Prelude.Instances hiding (FoldlSym0, sFoldl)
import Data.Singletons.Prelude.Monad.Internal
import Data.Singletons.Prelude.Monoid
import Data.Singletons.Prelude.Num
import Data.Singletons.Prelude.Ord
import Data.Singletons.Prelude.Semigroup.Internal
import Data.Singletons.Prelude.Show
import Data.Singletons.Single

{-
Const's argument `b` is poly-kinded, and as a result, it's very, very tricky to
promote or single it without running into CUSK issues. Here is the approach that
we take:

1. Define Const's singleton (and other things that would have been generated by
   genSingletons, such as its SingKind instance) by hand.
2. For other things which can be generated with Template Haskell, we always
   make sure to use an explicit (b :: k) signature to ensure that the generated
   code doesn't mention an underdetermined type variable `b`.

Note that we would run into the same issues of needing an explicit kind
signature everywhere even if we had restricted the kind of `b` to Type in
its singleton, and GHC would still try to kind-generalize the type `Const a b`
in promoted types and the like. Since we have to experience some amount of pain
either way, we opt for the more permissive choice of making it poly-kinded.
-}

data instance Sing :: forall (k :: Type) (a :: Type) (b :: k). Const a b -> Type where
  SConst :: { sGetConst :: Sing a } -> Sing ('Const a)
type SConst = (Sing :: Const a (b :: k) -> Type)
instance SingKind a => SingKind (Const a b) where
  type Demote (Const a b) = Const (Demote a) b
  fromSing (SConst sa) = Const (fromSing sa)
  toSing (Const a) = withSomeSing a $ SomeSing . SConst
instance SingI a => SingI ('Const a) where
  sing = SConst sing

data ConstSym0 :: forall (k :: Type) (a :: Type) (b :: k). a ~> Const a b
type instance Apply ConstSym0 x = 'Const x
type ConstSym1 (a :: Type) = 'Const a
instance SingI ConstSym0 where
  sing = singFun1 SConst
instance SingI (TyCon1 'Const) where
  sing = singFun1 SConst

$(singletons [d|
  type family GetConst (x :: Const a (b :: k)) :: a where
    GetConst ('Const x) = x
  |])

$(singletonsOnly [d|
  deriving instance Bounded a => Bounded (Const a (b :: k))
  deriving instance Eq      a => Eq      (Const a (b :: k))
  deriving instance Ord     a => Ord     (Const a (b :: k))

  -- deriving instance Enum a => Enum (Const a (b :: k))
  instance Enum a => Enum (Const a (b :: k)) where
    succ (Const x)     = Const (succ x)
    pred (Const x)     = Const (pred x)
    toEnum i           = Const (toEnum i)
    fromEnum (Const x) = fromEnum x
    enumFromTo (Const x) (Const y) = map Const (enumFromTo x y)
    enumFromThenTo (Const x) (Const y) (Const z) =
        map Const (enumFromThenTo x y z)

  -- deriving instance Monoid a => Monoid (Const a (b :: k))
  instance Monoid a => Monoid (Const a (b :: k)) where
    mempty = Const mempty

  -- deriving instance Num a => Num (Const a (b :: k))
  instance Num a => Num (Const a (b :: k)) where
    Const x + Const y = Const (x + y)
    Const x - Const y = Const (x - y)
    Const x * Const y = Const (x * y)
    negate (Const x)  = Const (negate x)
    abs    (Const x)  = Const (abs    x)
    signum (Const x)  = Const (signum x)
    fromInteger n     = Const (fromInteger n)

  -- deriving instance Semigroup a => Semigroup (Const a (b :: k))
  instance Semigroup a => Semigroup (Const a (b :: k)) where
    Const x <> Const y = Const (x <> y)

  -- -| This instance would be equivalent to the derived instances of the
  -- 'Const' newtype if the 'runConst' field were removed
  instance Show a => Show (Const a (b :: k)) where
      showsPrec d (Const x) = showParen (d > 10) $
                              showString "Const " . showsPrec 11 x

  -- deriving instance Functor (Const m)
  instance Functor (Const m) where
      fmap _ (Const v) = Const v

  -- deriving instance Foldable (Const m)
  instance Foldable (Const m) where
      foldMap _ _ = mempty

  instance Monoid m => Applicative (Const m) where
      pure _ = Const mempty
      liftA2 _ (Const x) (Const y) = Const (x `mappend` y)
      Const x <*> Const y = Const (x `mappend` y)
  |])
