Singletons/T54.hs:(0,0)-(0,0): Splicing declarations
    singletons
      [d| g :: Bool -> Bool
          g e = (case [not] of { [_] -> not }) e |]
  ======>
    g :: Bool -> Bool
    g e = (case [not] of { [_] -> not }) e
    type Let0123456789876543210Scrutinee_0123456789876543210Sym1 t =
        Let0123456789876543210Scrutinee_0123456789876543210 t
    instance SuppressUnusedWarnings Let0123456789876543210Scrutinee_0123456789876543210Sym0 where
      suppressUnusedWarnings _
        = snd
            ((GHC.Tuple.(,)
                Let0123456789876543210Scrutinee_0123456789876543210Sym0KindInference)
               GHC.Tuple.())
    data Let0123456789876543210Scrutinee_0123456789876543210Sym0 l
      = forall arg. SameKind (Apply Let0123456789876543210Scrutinee_0123456789876543210Sym0 arg) (Let0123456789876543210Scrutinee_0123456789876543210Sym1 arg) =>
        Let0123456789876543210Scrutinee_0123456789876543210Sym0KindInference
    type instance Apply Let0123456789876543210Scrutinee_0123456789876543210Sym0 l = Let0123456789876543210Scrutinee_0123456789876543210 l
    type family Let0123456789876543210Scrutinee_0123456789876543210 e where
      Let0123456789876543210Scrutinee_0123456789876543210 e = Apply (Apply (:$) NotSym0) '[]
    type family Case_0123456789876543210 e t where
      Case_0123456789876543210 e '[_z_0123456789876543210] = NotSym0
    type GSym1 (t :: Bool) = G t
    instance SuppressUnusedWarnings GSym0 where
      suppressUnusedWarnings _
        = snd ((GHC.Tuple.(,) GSym0KindInference) GHC.Tuple.())
    data GSym0 (l :: TyFun Bool Bool)
      = forall arg. SameKind (Apply GSym0 arg) (GSym1 arg) =>
        GSym0KindInference
    type instance Apply GSym0 l = G l
    type family G (a :: Bool) :: Bool where
      G e = Apply (Case_0123456789876543210 e (Let0123456789876543210Scrutinee_0123456789876543210Sym1 e)) e
    sG :: forall (t :: Bool). Sing t -> Sing (Apply GSym0 t :: Bool)
    sG sE
      = let
          lambda :: forall e. t ~ e => Sing e -> Sing (Apply GSym0 t :: Bool)
          lambda e
            = (applySing
                 (let
                    sScrutinee_0123456789876543210 ::
                      Sing (Let0123456789876543210Scrutinee_0123456789876543210Sym1 e)
                    sScrutinee_0123456789876543210
                      = (applySing
                           ((applySing ((singFun2 (Proxy :: Proxy (:$))) SCons))
                              ((singFun1 (Proxy :: Proxy NotSym0)) sNot)))
                          SNil
                  in  case sScrutinee_0123456789876543210 of {
                        SCons _s_z_0123456789876543210 SNil
                          -> let
                               lambda ::
                                 forall _z_0123456789876543210.
                                 Apply (Apply (:$) _z_0123456789876543210) '[] ~ Let0123456789876543210Scrutinee_0123456789876543210Sym1 e =>
                                 Sing _z_0123456789876543210
                                 -> Sing (Case_0123456789876543210 e (Apply (Apply (:$) _z_0123456789876543210) '[]))
                               lambda _z_0123456789876543210
                                 = (singFun1 (Proxy :: Proxy NotSym0)) sNot
                             in lambda _s_z_0123456789876543210 } ::
                        Sing (Case_0123456789876543210 e (Let0123456789876543210Scrutinee_0123456789876543210Sym1 e))))
                e
        in lambda sE
