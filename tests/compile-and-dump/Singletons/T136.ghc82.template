Singletons/T136.hs:(0,0)-(0,0): Splicing declarations
    singletons
      [d| instance Enum BiNat where
            succ [] = [True]
            succ (False : as) = True : as
            succ (True : as) = False : succ as
            pred [] = error "pred 0"
            pred (False : as) = True : pred as
            pred (True : as) = False : as
            toEnum i
              | i < 0 = error "negative toEnum"
              | i == 0 = []
              | otherwise = succ (toEnum (pred i))
            fromEnum [] = 0
            fromEnum (False : as) = 2 * fromEnum as
            fromEnum (True : as) = 1 + 2 * fromEnum as |]
  ======>
    instance Enum BiNat where
      succ GHC.Types.[] = [True]
      succ (False GHC.Types.: as) = (True GHC.Types.: as)
      succ (True GHC.Types.: as) = (False GHC.Types.: (succ as))
      pred GHC.Types.[] = error "pred 0"
      pred (False GHC.Types.: as) = (True GHC.Types.: (pred as))
      pred (True GHC.Types.: as) = (False GHC.Types.: as)
      toEnum i
        | (i < 0) = error "negative toEnum"
        | (i == 0) = []
        | otherwise = succ (toEnum (pred i))
      fromEnum GHC.Types.[] = 0
      fromEnum (False GHC.Types.: as) = (2 * (fromEnum as))
      fromEnum (True GHC.Types.: as) = (1 + (2 * (fromEnum as)))
    type family Succ_0123456789876543210 (a :: [Bool]) :: [Bool] where
      Succ_0123456789876543210 '[] = Apply (Apply (:$) TrueSym0) '[]
      Succ_0123456789876543210 ((:) False as) = Apply (Apply (:$) TrueSym0) as
      Succ_0123456789876543210 ((:) True as) = Apply (Apply (:$) FalseSym0) (Apply SuccSym0 as)
    type Succ_0123456789876543210Sym1 (t :: [Bool]) =
        Succ_0123456789876543210 t
    instance SuppressUnusedWarnings Succ_0123456789876543210Sym0 where
      suppressUnusedWarnings _
        = snd
            ((GHC.Tuple.(,) Succ_0123456789876543210Sym0KindInference)
               GHC.Tuple.())
    data Succ_0123456789876543210Sym0 (l :: TyFun [Bool] [Bool])
      = forall arg. SameKind (Apply Succ_0123456789876543210Sym0 arg) (Succ_0123456789876543210Sym1 arg) =>
        Succ_0123456789876543210Sym0KindInference
    type instance Apply Succ_0123456789876543210Sym0 l = Succ_0123456789876543210 l
    type family Pred_0123456789876543210 (a :: [Bool]) :: [Bool] where
      Pred_0123456789876543210 '[] = Apply ErrorSym0 "pred 0"
      Pred_0123456789876543210 ((:) False as) = Apply (Apply (:$) TrueSym0) (Apply PredSym0 as)
      Pred_0123456789876543210 ((:) True as) = Apply (Apply (:$) FalseSym0) as
    type Pred_0123456789876543210Sym1 (t :: [Bool]) =
        Pred_0123456789876543210 t
    instance SuppressUnusedWarnings Pred_0123456789876543210Sym0 where
      suppressUnusedWarnings _
        = snd
            ((GHC.Tuple.(,) Pred_0123456789876543210Sym0KindInference)
               GHC.Tuple.())
    data Pred_0123456789876543210Sym0 (l :: TyFun [Bool] [Bool])
      = forall arg. SameKind (Apply Pred_0123456789876543210Sym0 arg) (Pred_0123456789876543210Sym1 arg) =>
        Pred_0123456789876543210Sym0KindInference
    type instance Apply Pred_0123456789876543210Sym0 l = Pred_0123456789876543210 l
    type family Case_0123456789876543210 i arg_0123456789876543210 t where
      Case_0123456789876543210 i arg_0123456789876543210 True = '[]
      Case_0123456789876543210 i arg_0123456789876543210 False = Apply SuccSym0 (Apply ToEnumSym0 (Apply PredSym0 i))
    type family Case_0123456789876543210 i arg_0123456789876543210 t where
      Case_0123456789876543210 i arg_0123456789876543210 True = Apply ErrorSym0 "negative toEnum"
      Case_0123456789876543210 i arg_0123456789876543210 False = Case_0123456789876543210 i arg_0123456789876543210 (Apply (Apply (:==$) i) (FromInteger 0))
    type family Case_0123456789876543210 arg_0123456789876543210 t where
      Case_0123456789876543210 arg_0123456789876543210 i = Case_0123456789876543210 i arg_0123456789876543210 (Apply (Apply (:<$) i) (FromInteger 0))
    type family ToEnum_0123456789876543210 (a :: GHC.Types.Nat) :: [Bool] where
      ToEnum_0123456789876543210 arg_0123456789876543210 = Case_0123456789876543210 arg_0123456789876543210 arg_0123456789876543210
    type ToEnum_0123456789876543210Sym1 (t :: GHC.Types.Nat) =
        ToEnum_0123456789876543210 t
    instance SuppressUnusedWarnings ToEnum_0123456789876543210Sym0 where
      suppressUnusedWarnings _
        = snd
            ((GHC.Tuple.(,) ToEnum_0123456789876543210Sym0KindInference)
               GHC.Tuple.())
    data ToEnum_0123456789876543210Sym0 (l :: TyFun GHC.Types.Nat [Bool])
      = forall arg. SameKind (Apply ToEnum_0123456789876543210Sym0 arg) (ToEnum_0123456789876543210Sym1 arg) =>
        ToEnum_0123456789876543210Sym0KindInference
    type instance Apply ToEnum_0123456789876543210Sym0 l = ToEnum_0123456789876543210 l
    type family FromEnum_0123456789876543210 (a :: [Bool]) :: GHC.Types.Nat where
      FromEnum_0123456789876543210 '[] = FromInteger 0
      FromEnum_0123456789876543210 ((:) False as) = Apply (Apply (:*$) (FromInteger 2)) (Apply FromEnumSym0 as)
      FromEnum_0123456789876543210 ((:) True as) = Apply (Apply (:+$) (FromInteger 1)) (Apply (Apply (:*$) (FromInteger 2)) (Apply FromEnumSym0 as))
    type FromEnum_0123456789876543210Sym1 (t :: [Bool]) =
        FromEnum_0123456789876543210 t
    instance SuppressUnusedWarnings FromEnum_0123456789876543210Sym0 where
      suppressUnusedWarnings _
        = snd
            ((GHC.Tuple.(,) FromEnum_0123456789876543210Sym0KindInference)
               GHC.Tuple.())
    data FromEnum_0123456789876543210Sym0 (l :: TyFun [Bool] GHC.Types.Nat)
      = forall arg. SameKind (Apply FromEnum_0123456789876543210Sym0 arg) (FromEnum_0123456789876543210Sym1 arg) =>
        FromEnum_0123456789876543210Sym0KindInference
    type instance Apply FromEnum_0123456789876543210Sym0 l = FromEnum_0123456789876543210 l
    instance PEnum [Bool] where
      type Succ (a :: [Bool]) = Apply Succ_0123456789876543210Sym0 a
      type Pred (a :: [Bool]) = Apply Pred_0123456789876543210Sym0 a
      type ToEnum (a :: GHC.Types.Nat) = Apply ToEnum_0123456789876543210Sym0 a
      type FromEnum (a :: [Bool]) = Apply FromEnum_0123456789876543210Sym0 a
    instance SEnum [Bool] where
      sSucc ::
        forall (t :: [Bool]).
        Sing t
        -> Sing (Apply (SuccSym0 :: TyFun [Bool] [Bool]
                                    -> GHC.Types.Type) t :: [Bool])
      sPred ::
        forall (t :: [Bool]).
        Sing t
        -> Sing (Apply (PredSym0 :: TyFun [Bool] [Bool]
                                    -> GHC.Types.Type) t :: [Bool])
      sToEnum ::
        forall (t :: GHC.Types.Nat).
        Sing t
        -> Sing (Apply (ToEnumSym0 :: TyFun GHC.Types.Nat [Bool]
                                      -> GHC.Types.Type) t :: [Bool])
      sFromEnum ::
        forall (t :: [Bool]).
        Sing t
        -> Sing (Apply (FromEnumSym0 :: TyFun [Bool] GHC.Types.Nat
                                        -> GHC.Types.Type) t :: GHC.Types.Nat)
      sSucc SNil
        = let
            lambda :: t ~ '[] => Sing (Apply SuccSym0 t :: [Bool])
            lambda
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:$))) SCons)) STrue))
                  SNil
          in lambda
      sSucc (SCons SFalse sAs)
        = let
            lambda ::
              forall as.
              t ~ Apply (Apply (:$) FalseSym0) as =>
              Sing as -> Sing (Apply SuccSym0 t :: [Bool])
            lambda as
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:$))) SCons)) STrue))
                  as
          in lambda sAs
      sSucc (SCons STrue sAs)
        = let
            lambda ::
              forall as.
              t ~ Apply (Apply (:$) TrueSym0) as =>
              Sing as -> Sing (Apply SuccSym0 t :: [Bool])
            lambda as
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:$))) SCons)) SFalse))
                  ((applySing ((singFun1 (Proxy :: Proxy SuccSym0)) sSucc)) as)
          in lambda sAs
      sPred SNil
        = let
            lambda :: t ~ '[] => Sing (Apply PredSym0 t :: [Bool])
            lambda = sError (sing :: Sing "pred 0")
          in lambda
      sPred (SCons SFalse sAs)
        = let
            lambda ::
              forall as.
              t ~ Apply (Apply (:$) FalseSym0) as =>
              Sing as -> Sing (Apply PredSym0 t :: [Bool])
            lambda as
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:$))) SCons)) STrue))
                  ((applySing ((singFun1 (Proxy :: Proxy PredSym0)) sPred)) as)
          in lambda sAs
      sPred (SCons STrue sAs)
        = let
            lambda ::
              forall as.
              t ~ Apply (Apply (:$) TrueSym0) as =>
              Sing as -> Sing (Apply PredSym0 t :: [Bool])
            lambda as
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:$))) SCons)) SFalse))
                  as
          in lambda sAs
      sToEnum sArg_0123456789876543210
        = let
            lambda ::
              forall arg_0123456789876543210.
              t ~ arg_0123456789876543210 =>
              Sing arg_0123456789876543210 -> Sing (Apply ToEnumSym0 t :: [Bool])
            lambda arg_0123456789876543210
              = case arg_0123456789876543210 of {
                  sI
                    -> let
                         lambda ::
                           forall i.
                           i ~ arg_0123456789876543210 =>
                           Sing i
                           -> Sing (Case_0123456789876543210 arg_0123456789876543210 i :: [Bool])
                         lambda i
                           = case
                                 (applySing
                                    ((applySing ((singFun2 (Proxy :: Proxy (:<$))) (%:<))) i))
                                   (sFromInteger (sing :: Sing 0))
                             of
                               STrue
                                 -> let
                                      lambda ::
                                        TrueSym0 ~ Apply (Apply (:<$) i) (FromInteger 0) =>
                                        Sing (Case_0123456789876543210 i arg_0123456789876543210 TrueSym0 :: [Bool])
                                      lambda = sError (sing :: Sing "negative toEnum")
                                    in lambda
                               SFalse
                                 -> let
                                      lambda ::
                                        FalseSym0 ~ Apply (Apply (:<$) i) (FromInteger 0) =>
                                        Sing (Case_0123456789876543210 i arg_0123456789876543210 FalseSym0 :: [Bool])
                                      lambda
                                        = case
                                              (applySing
                                                 ((applySing
                                                     ((singFun2 (Proxy :: Proxy (:==$))) (%:==)))
                                                    i))
                                                (sFromInteger (sing :: Sing 0))
                                          of
                                            STrue
                                              -> let
                                                   lambda ::
                                                     TrueSym0 ~ Apply (Apply (:==$) i) (FromInteger 0) =>
                                                     Sing (Case_0123456789876543210 i arg_0123456789876543210 TrueSym0 :: [Bool])
                                                   lambda = SNil
                                                 in lambda
                                            SFalse
                                              -> let
                                                   lambda ::
                                                     FalseSym0 ~ Apply (Apply (:==$) i) (FromInteger 0) =>
                                                     Sing (Case_0123456789876543210 i arg_0123456789876543210 FalseSym0 :: [Bool])
                                                   lambda
                                                     = (applySing
                                                          ((singFun1 (Proxy :: Proxy SuccSym0))
                                                             sSucc))
                                                         ((applySing
                                                             ((singFun1 (Proxy :: Proxy ToEnumSym0))
                                                                sToEnum))
                                                            ((applySing
                                                                ((singFun1
                                                                    (Proxy :: Proxy PredSym0))
                                                                   sPred))
                                                               i))
                                                 in lambda ::
                                            Sing (Case_0123456789876543210 i arg_0123456789876543210 (Apply (Apply (:==$) i) (FromInteger 0)) :: [Bool])
                                    in lambda ::
                               Sing (Case_0123456789876543210 i arg_0123456789876543210 (Apply (Apply (:<$) i) (FromInteger 0)) :: [Bool])
                       in lambda sI } ::
                  Sing (Case_0123456789876543210 arg_0123456789876543210 arg_0123456789876543210 :: [Bool])
          in lambda sArg_0123456789876543210
      sFromEnum SNil
        = let
            lambda :: t ~ '[] => Sing (Apply FromEnumSym0 t :: GHC.Types.Nat)
            lambda = sFromInteger (sing :: Sing 0)
          in lambda
      sFromEnum (SCons SFalse sAs)
        = let
            lambda ::
              forall as.
              t ~ Apply (Apply (:$) FalseSym0) as =>
              Sing as -> Sing (Apply FromEnumSym0 t :: GHC.Types.Nat)
            lambda as
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:*$))) (%:*)))
                      (sFromInteger (sing :: Sing 2))))
                  ((applySing ((singFun1 (Proxy :: Proxy FromEnumSym0)) sFromEnum))
                     as)
          in lambda sAs
      sFromEnum (SCons STrue sAs)
        = let
            lambda ::
              forall as.
              t ~ Apply (Apply (:$) TrueSym0) as =>
              Sing as -> Sing (Apply FromEnumSym0 t :: GHC.Types.Nat)
            lambda as
              = (applySing
                   ((applySing ((singFun2 (Proxy :: Proxy (:+$))) (%:+)))
                      (sFromInteger (sing :: Sing 1))))
                  ((applySing
                      ((applySing ((singFun2 (Proxy :: Proxy (:*$))) (%:*)))
                         (sFromInteger (sing :: Sing 2))))
                     ((applySing ((singFun1 (Proxy :: Proxy FromEnumSym0)) sFromEnum))
                        as))
          in lambda sAs
